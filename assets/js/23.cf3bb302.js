(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{437:function(_,v,e){"use strict";e.r(v);var d=e(54),o=Object(d.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"索引的使用策略及优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引的使用策略及优缺点"}},[_._v("#")]),_._v(" 索引的使用策略及优缺点")]),_._v(" "),e("p",[e("strong",[_._v("使用索引")])]),_._v(" "),e("p",[_._v("主键自动建立唯一索引。\n经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引。\n查询中与其他表关联的字段，外键关系建立索引。\n经常用于聚合函数的列要建立索引，如min()，max()等的聚合函数。")]),_._v(" "),e("p",[e("strong",[_._v("不使用索引")])]),_._v(" "),e("p",[_._v("经常增删改的列不要建立索引。\n有大量重复的列不建立索引。\n表记录太少不要建立索引，因为数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果 。")]),_._v(" "),e("p",[e("strong",[_._v("最左匹配原则")])]),_._v(" "),e("p",[_._v("建立联合索引的时候都会默认从最左边开始，所以索引列的顺序很重要，建立索引的时候就应该把最常用的放在左边，使用select的时候也是这样，从最左边的开始，依次匹配右边的。")]),_._v(" "),e("p",[e("strong",[_._v("优点")])]),_._v(" "),e("p",[_._v("可以保证数据库表中每一行的数据的唯一性。\n可以大大加快数据的索引速度。\n加速表与表之间的连接。\n可以显著的减少查询中分组和排序的时间。")]),_._v(" "),e("p",[e("strong",[_._v("缺点")])]),_._v(" "),e("p",[_._v("创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。\n索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大，其实建立索引就是以空间换时间。\n表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了维护效率。")]),_._v(" "),e("h2",{attrs:{id:"explain有什么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#explain有什么用"}},[_._v("#")]),_._v(" Explain有什么用")]),_._v(" "),e("p",[_._v("当"),e("code",[_._v("Explain")]),_._v("与 "),e("code",[_._v("SQL")]),_._v("语句一起使用时，"),e("code",[_._v("MySQL")]),_._v(" 会显示来自优化器关于SQL执行的信息。也就是说，"),e("code",[_._v("MySQL")]),_._v("解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。")]),_._v(" "),e("ul",[e("li",[_._v("表的加载顺序")]),_._v(" "),e("li",[e("code",[_._v("sql")]),_._v(" 的查询类型")]),_._v(" "),e("li",[_._v("可能用到哪些索引，哪些索引又被实际使用")]),_._v(" "),e("li",[_._v("表与表之间的引用关系")]),_._v(" "),e("li",[_._v("一个表中有多少行被优化器查询")])]),_._v(" "),e("h2",{attrs:{id:"explain有哪些信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#explain有哪些信息"}},[_._v("#")]),_._v(" Explain有哪些信息")]),_._v(" "),e("p",[e("code",[_._v("Explain")]),_._v(" 执行计划包含字段信息如下：分别是 "),e("code",[_._v("id")]),_._v("、"),e("code",[_._v("select_type")]),_._v("、"),e("code",[_._v("table")]),_._v("、"),e("code",[_._v("partitions")]),_._v("、"),e("code",[_._v("type")]),_._v("、"),e("code",[_._v("possible_keys")]),_._v("、"),e("code",[_._v("key")]),_._v("、"),e("code",[_._v("key_len")]),_._v("、"),e("code",[_._v("ref")]),_._v("、"),e("code",[_._v("rows")]),_._v("、"),e("code",[_._v("filtered")]),_._v("、"),e("code",[_._v("Extra")]),_._v(" 12个字段。")]),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("关键词")]),_._v(" "),e("th",[_._v("介绍")]),_._v(" "),e("th",[_._v("不同情况")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("id")]),_._v(" "),e("td",[_._v("表示查询中执行select子句或者操作表的顺序，"),e("strong",[e("code",[_._v("id")]),_._v("的值越大，代表优先级越高，越先执行")]),_._v("。")]),_._v(" "),e("td",[e("code",[_._v("id")]),_._v("大致会出现 3种情况："),e("br"),e("strong",[e("code",[_._v("id")]),_._v("相同")]),_._v(":看到三条记录的"),e("code",[_._v("id")]),_._v("都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定"),e("br"),e("strong",[e("code",[_._v("id")]),_._v("不同")]),_._v(":如果我们的 "),e("code",[_._v("SQL")]),_._v(" 中存在子查询，那么 "),e("code",[_._v("id")]),_._v("的序号会递增，"),e("code",[_._v("id")]),_._v("值越大优先级越高，越先被执行 。当三个表依次嵌套，发现最里层的子查询 "),e("code",[_._v("id")]),_._v("最大，最先执行。"),e("br"),e("strong",[_._v("以上两种同时存在")]),_._v(":将上边的 "),e("code",[_._v("SQL")]),_._v(" 稍微修改一下，增加一个子查询，发现 "),e("code",[_._v("id")]),_._v("的以上两种同时存在。相同"),e("code",[_._v("id")]),_._v("划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 "),e("code",[_._v("id")]),_._v("值越大，优先级越高，越先执行。")])]),_._v(" "),e("tr",[e("td",[_._v("select_type")]),_._v(" "),e("td",[_._v("表示 "),e("code",[_._v("select")]),_._v(" 查询的类型，主要是用于区分各种复杂的查询，例如："),e("code",[_._v("普通查询")]),_._v("、"),e("code",[_._v("联合查询")]),_._v("、"),e("code",[_._v("子查询")]),_._v("等")]),_._v(" "),e("td",[e("code",[_._v("SIMPLE")]),_._v("：表示最简单的 select 查询语句，也就是在查询中不包含子查询或者 "),e("code",[_._v("union")]),_._v("交并差集等操作"),e("br"),e("code",[_._v("PRIMARY")]),_._v("：当查询语句中包含任何复杂的子部分，最外层查询则被标记为"),e("code",[_._v("PRIMARY")]),e("br"),e("code",[_._v("SUBQUERY")]),_._v("：当 "),e("code",[_._v("select")]),_._v(" 或 "),e("code",[_._v("where")]),_._v(" 列表中包含了子查询，该子查询被标记为："),e("code",[_._v("SUBQUERY")]),_._v(" "),e("br"),e("code",[_._v("DERIVED")]),_._v("：表示包含在from子句中的子查询的select，在我们的from列表中包含的子查询会被标记为"),e("code",[_._v("derived")]),e("br"),e("code",[_._v("UNION")]),_._v("：如果"),e("code",[_._v("union")]),_._v("后边又出现的"),e("code",[_._v("select")]),_._v(" 语句，则会被标记为"),e("code",[_._v("union")]),_._v("；若 "),e("code",[_._v("union")]),_._v(" 包含在 "),e("code",[_._v("from")]),_._v(" 子句的子查询中，外层 "),e("code",[_._v("select")]),_._v(" 将被标记为 "),e("code",[_._v("derived")]),_._v("。"),e("br"),e("code",[_._v("UNION RESULT")]),_._v("：代表从"),e("code",[_._v("union")]),_._v("的临时表中读取数据，而"),e("code",[_._v("table")]),_._v("列的"),e("code",[_._v("<union1,4>")]),_._v("表示用第一个和第四个"),e("code",[_._v("select")]),_._v("的结果进行"),e("code",[_._v("union")]),_._v("操作。")])]),_._v(" "),e("tr",[e("td",[_._v("table")]),_._v(" "),e("td",[_._v("查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表，例如上边的DERIVED、<union1,4>等。")]),_._v(" "),e("td")]),_._v(" "),e("tr",[e("td",[_._v("partitions")]),_._v(" "),e("td",[_._v("查询时匹配到的分区信息，对于非分区表值为"),e("code",[_._v("NULL")]),_._v("，当查询的是分区表时，"),e("code",[_._v("partitions")]),_._v("显示分区表命中的分区情况。")]),_._v(" "),e("td")]),_._v(" "),e("tr",[e("td",[_._v("type")]),_._v(" "),e("td",[_._v("查询使用了何种类型，它在 SQL优化中是一个非常重要的指标，以下性能从好到坏依次是："),e("code",[_._v("system")]),_._v("  > "),e("code",[_._v("const")]),_._v(" > "),e("code",[_._v("eq_ref")]),_._v(" > "),e("code",[_._v("ref")]),_._v("  > "),e("code",[_._v("ref_or_null")]),_._v(" > "),e("code",[_._v("index_merge")]),_._v(" > "),e("code",[_._v("unique_subquery")]),_._v(" > "),e("code",[_._v("index_subquery")]),_._v(" > "),e("code",[_._v("range")]),_._v(" > "),e("code",[_._v("index")]),_._v(" > "),e("code",[_._v("ALL")])]),_._v(" "),e("td",[e("strong",[e("code",[_._v("system")])]),_._v("： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。"),e("br"),e("strong",[e("code",[_._v("const")])]),_._v("：表示查询时命中 "),e("code",[_._v("primary key")]),_._v(" 主键或者 "),e("code",[_._v("unique")]),_._v(" 唯一索引，或者被连接的部分是一个常量("),e("code",[_._v("const")]),_._v(")值。这类扫描效率极高，返回数据量少，速度非常快。"),e("br"),e("strong",[e("code",[_._v("eq_ref")])]),_._v("：查询时命中主键"),e("code",[_._v("primary key")]),_._v(" 或者 "),e("code",[_._v("unique key")]),_._v("索引，"),e("code",[_._v("type")]),_._v(" 就是 "),e("code",[_._v("eq_ref")]),_._v("。"),e("br"),e("strong",[e("code",[_._v("ref")])]),_._v("：区别于"),e("code",[_._v("eq_ref")]),_._v(" ，"),e("code",[_._v("ref")]),_._v("表示使用非唯一性索引，会找到很多个符合条件的行。"),e("br"),e("strong",[e("code",[_._v("ref_or_null")])]),_._v("：这种连接类型类似于 ref，区别在于 "),e("code",[_._v("MySQL")]),_._v("会额外搜索包含"),e("code",[_._v("NULL")]),_._v("值的行。"),e("br"),e("strong",[e("code",[_._v("index_merge")])]),_._v("：使用了索引合并优化方法，查询使用了两个以上的索引。"),e("br"),e("strong",[e("code",[_._v("unique_subquery")])]),_._v("：替换下面的 "),e("code",[_._v("IN")]),_._v("子查询，子查询返回不重复的集合。"),e("br"),e("strong",[e("code",[_._v("index_subquery")])]),_._v("：区别于"),e("code",[_._v("unique_subquery")]),_._v("，用于非唯一索引，可以返回重复值"),e("br"),e("strong",[e("code",[_._v("range")])]),_._v("：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在"),e("code",[_._v("where")]),_._v("语句中使用 "),e("code",[_._v("bettween...and")]),_._v("、"),e("code",[_._v("<")]),_._v("、"),e("code",[_._v(">")]),_._v("、"),e("code",[_._v("<=")]),_._v("、"),e("code",[_._v("in")]),_._v(" 等条件查询 "),e("code",[_._v("type")]),_._v(" 都是 "),e("code",[_._v("range")]),_._v("。"),e("br"),e("strong",[e("code",[_._v("index")])]),_._v("："),e("code",[_._v("Index")]),_._v(" 与"),e("code",[_._v("ALL")]),_._v(" 其实都是读全表，区别在于"),e("code",[_._v("index")]),_._v("是遍历索引树读取，而"),e("code",[_._v("ALL")]),_._v("是从硬盘中读取。"),e("br"),e("code",[_._v("ALL")]),_._v("：将遍历全表以找到匹配的行，性能最差。")])]),_._v(" "),e("tr",[e("td",[_._v("possible_keys")]),_._v(" "),e("td",[_._v("表示在"),e("code",[_._v("MySQL")]),_._v("中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，"),e("strong",[_._v("但这个索引并不定一会是最终查询数据时所被用到的索引")]),_._v("。具体请参考上边的例子。")]),_._v(" "),e("td")]),_._v(" "),e("tr",[e("td",[_._v("key")]),_._v(" "),e("td",[_._v("区别于"),e("code",[_._v("possible_keys")]),_._v("，key是查询中实际使用到的索引，若没有使用索引，显示为"),e("code",[_._v("NULL")]),_._v("。具体请参考上边的例子。")]),_._v(" "),e("td")]),_._v(" "),e("tr",[e("td",[_._v("key_len")]),_._v(" "),e("td",[_._v("表示查询用到的索引长度（字节数），原则上长度越短越好 。")]),_._v(" "),e("td",[_._v("单列索引，那么需要将整个索引长度算进去； "),e("br"),_._v("多列索引，不是所有列都能用到，需要计算查询中实际用到的列。")])]),_._v(" "),e("tr",[e("td",[_._v("ref")]),_._v(" "),e("td",[_._v("常见的有："),e("code",[_._v("const")]),_._v("，"),e("code",[_._v("func")]),_._v("，"),e("code",[_._v("null")]),_._v("，字段名")]),_._v(" "),e("td",[_._v("当使用常量等值查询，显示"),e("code",[_._v("const")]),_._v("，"),e("br"),_._v(" 当关联查询时，会显示相应关联表的"),e("code",[_._v("关联字段")]),_._v(" "),e("br"),_._v(" 如果查询条件使用了"),e("code",[_._v("表达式")]),_._v("、"),e("code",[_._v("函数")]),_._v("，或者条件列发生内部隐式转换，可能显示为"),e("code",[_._v("func")]),_._v(" "),e("br"),_._v(" 其他情况"),e("code",[_._v("null")])])]),_._v(" "),e("tr",[e("td",[_._v("rows")]),_._v(" "),e("td",[_._v("以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。")]),_._v(" "),e("td")]),_._v(" "),e("tr",[e("td",[_._v("filtered")]),_._v(" "),e("td",[_._v("这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。")]),_._v(" "),e("td")]),_._v(" "),e("tr",[e("td",[_._v("Extra")]),_._v(" "),e("td",[_._v("不适合在其他列中显示的信息，"),e("code",[_._v("Explain")]),_._v(" 中的很多额外的信息会在 "),e("code",[_._v("Extra")]),_._v(" 字段显示。")]),_._v(" "),e("td",[e("code",[_._v("Using index")]),_._v("：我们在相应的 "),e("code",[_._v("select")]),_._v(" 操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，"),e("code",[_._v("SQl")]),_._v("优化中理想的状态。"),e("br"),e("code",[_._v("Using where")]),_._v("：查询时未找到可用的索引，进而通过"),e("code",[_._v("where")]),_._v("条件过滤获取所需数据，但要注意的是并不是所有带"),e("code",[_._v("where")]),_._v("语句的查询都会显示"),e("code",[_._v("Using where")]),_._v("。"),e("br"),e("code",[_._v("Using temporary")]),_._v("：表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。"),e("br"),e("code",[_._v("Using filesort")]),_._v("：表示无法利用索引完成的排序操作，也就是"),e("code",[_._v("ORDER BY")]),_._v("的字段没有索引，通常这样的SQL都是需要优化的。"),e("br"),e("code",[_._v("Using join buffer")]),_._v("：在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。"),e("br"),e("code",[_._v("Impossible where")]),_._v("：表示在我们用不太正确的"),e("code",[_._v("where")]),_._v("语句，导致没有符合条件的行。"),e("br"),e("code",[_._v("No tables used")]),_._v("：我们的查询语句中没有"),e("code",[_._v("FROM")]),_._v("子句，或者有 "),e("code",[_._v("FROM DUAL")]),_._v("子句。")])])])])])}),[],!1,null,null,null);v.default=o.exports}}]);