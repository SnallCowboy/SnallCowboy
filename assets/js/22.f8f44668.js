(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{438:function(t,e,a){"use strict";a.r(e);var l=a(54),s=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"索引设计原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引设计原则"}},[t._v("#")]),t._v(" 索引设计原则")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。")])]),t._v(" "),a("li",[a("p",[t._v("对查询频次较高，且数据量比较大的表建立索引。")])]),t._v(" "),a("li",[a("p",[t._v("索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。")])]),t._v(" "),a("li",[a("p",[t._v("使用唯一索引，区分度越高，使用索引的效率越高。")])]),t._v(" "),a("li",[a("p",[t._v("索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。")])]),t._v(" "),a("li",[a("p",[t._v("使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。")])]),t._v(" "),a("li",[a("p",[t._v("利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("创建复合索引:\n\n\tCREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);\n\n就相当于\n\t对name 创建索引 ;\n\t对name , email 创建了索引 ;\n\t对name , email, status 创建了索引 ;\n")])])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);